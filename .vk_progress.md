# Progress: Unfinished Task Attempts Investigation

## Status: complete

## Plan File
`/home/david/.claude/plans/eager-floating-key.md`

## Session 1: Add Diagnostic Logging - COMPLETE

### Goal
Add diagnostic logging to understand when and why task sessions stop prematurely.

### Completed Items
- [x] Read and understood `protocol.rs` - Result message handling at line 70-76
- [x] Read and understood `container.rs` - exit monitor logic at lines 276-430
- [x] Added logging to `protocol.rs` when Result message is received (breaks read loop)
- [x] Added logging to `container.rs` for exit monitor context (exec_id, exit_code, process_status, run_reason, task_attempt_id)
- [x] Added logging for decision points in exit monitor (success/cleanup_done flags, changes_committed, should_start_next)
- [x] All tests pass (`cargo test --workspace`)
- [x] Clippy passes with no warnings
- [x] Full validation passes (`npm run check`)
- [x] Manual testing completed (app runs correctly in light/dark mode, mobile/tablet/desktop)

### Files Changed

| File | Change |
|------|--------|
| `crates/executors/src/executors/claude/protocol.rs:70-77` | Added `tracing::info!` when Result message is received to log the value and indicate read loop is breaking |
| `crates/local-deployment/src/container.rs:347-355` | Added diagnostic logging for exit monitor context (exec_id, exit_code, process_status, run_reason, task_attempt_id) |
| `crates/local-deployment/src/container.rs:375-410` | Added logging when process is eligible for commit/next-action and at decision point |

### How Logging Will Help
When a task attempt stops prematurely, the logs will now show:
1. **Protocol level**: When Claude Code emits a `Result` message and what the value contains
2. **Exit monitor level**:
   - The process exit code and status
   - The run reason (CodingAgent, CleanupScript, etc.)
   - Whether success/cleanup_done conditions are met
   - Whether changes were committed
   - Whether next action should start (or if cleanup is being skipped)

This will help diagnose whether:
- Result messages are being emitted prematurely by Claude Code
- The process is exiting unexpectedly
- The "no changes" detection is triggering incorrectly

### Testing Summary
| Test | Result |
|------|--------|
| `cargo test --workspace` | ✓ Pass |
| `cargo clippy --all` | ✓ Pass |
| `npm run check` | ✓ Pass |
| Desktop light mode | ✓ Pass |
| Desktop dark mode | ✓ Pass |
| Mobile viewport | ✓ Pass |
| Tablet viewport | ✓ Pass |

## Session 2: Root Cause Analysis - COMPLETE

### Goal
Analyze code flow and existing logs to determine the root cause of premature task termination.

### Completed Items
- [x] Reviewed Session 1 diagnostic logging changes
- [x] Started dev server and verified app functionality
- [x] Analyzed existing task attempt logs from production database
- [x] Traced code flow from protocol.rs → container.rs exit monitor
- [x] Identified root cause of premature task finalization

### Root Cause Identified

**Primary Issue**: Premature task finalization when coding agent performs non-file-change work (like browser testing).

**Code Flow Analysis**:

1. **Protocol Level** (`crates/executors/src/executors/claude/protocol.rs:70-76`):
   - When Claude Code emits a `{"type": "result"}` JSON message, the protocol read loop **breaks immediately**
   - This is expected behavior per Claude Agent SDK - `Result` messages indicate session completion

2. **Process Exit** (`crates/executors/src/executors/claude.rs:306-309`):
   - Claude executor sets `exit_signal: None`, meaning exit monitor relies on OS process exit
   - The tokio task handling the SDK client completes when read loop finishes
   - Claude Code process may continue running briefly, then exits naturally

3. **Exit Monitor** (`crates/local-deployment/src/container.rs:326-427`):
   - Process exits with code 0 → `success=true`
   - `run_reason=CodingAgent`
   - `try_commit_changes()` is called, uses last assistant message as commit summary
   - If no git changes exist → `changes_committed=false`

4. **Premature Finalization** (`crates/local-deployment/src/container.rs:394-427`):
   ```rust
   let should_start_next = if matches!(
       ctx.execution_process.run_reason,
       ExecutionProcessRunReason::CodingAgent
   ) {
       changes_committed  // FALSE when doing browser testing!
   } else {
       true
   };

   if should_start_next {
       // Start next action (cleanup script)
   } else {
       // PROBLEM: Skips cleanup AND finalizes task!
       container.finalize_task(...).await;
   }
   ```

**Evidence from Logs** (from the original task attempt):
```bash
01:54:19 - Committing changes: 'Mobile viewport looks good... Now let me test tablet viewport and then light mode:'
01:54:19 - Skipping cleanup script for task attempt - no changes made by coding agent
```

The commit message shows the agent was **mid-task** ("Now let me test tablet viewport...") when it was finalized.

### The Bug

**Faulty Assumption**: The code assumes that if `changes_committed=false` for a `CodingAgent`, the agent did nothing useful and should skip cleanup + finalize immediately.

**Reality**: The agent may be doing valuable work that doesn't involve file changes:
- Browser testing with Playwright
- Running test suites
- Research/exploration
- Any verification that reads but doesn't write

### Potential Fix Approaches (for Session 3)

**Option A: Remove "no changes" shortcut entirely**
- Always run cleanup script regardless of git changes
- Pro: Simple, consistent behavior
- Con: May run unnecessary cleanup scripts

**Option B: Check Result message for explicit completion status**
- The `Result` message from Claude Code may contain a `subtype` or status field
- Only treat as "done" if explicitly marked as success
- Pro: More accurate signal
- Con: Requires understanding Claude SDK message format better

**Option C: Add configuration option**
- Allow tasks to opt-out of "no changes = done" behavior
- Pro: Flexible
- Con: Added complexity

**Recommended**: Start with Option A (simplest) and monitor. The cleanup script is lightweight and running it unnecessarily is better than premature finalization.

### Files Analyzed

| File | Key Lines | Purpose |
|------|-----------|---------|
| `crates/executors/src/executors/claude/protocol.rs` | 70-76 | Result message handling |
| `crates/executors/src/executors/claude/types.rs` | 9-22 | CLIMessage enum definition |
| `crates/executors/src/executors/claude/client.rs` | 176-179 | Non-control message forwarding |
| `crates/executors/src/executors/claude.rs` | 260-310 | Process spawn, exit_signal=None |
| `crates/local-deployment/src/container.rs` | 276-475 | Exit monitor and finalization logic |

### Testing Summary
| Test | Result |
|------|--------|
| Dev server startup | ✓ Pass (ports 4500/4501) |
| App functional | ✓ Pass |
| Code analysis complete | ✓ Pass |

## Session 3: Implement Fix - COMPLETE

### Goal
Implement Option A fix: Remove "no changes" shortcut so cleanup script always runs.

### Completed Items
- [x] Read current container.rs logic for exit monitoring
- [x] Modify logic to always run cleanup script (regardless of changes_committed)
- [x] Run cargo test --workspace
- [x] Run cargo clippy
- [x] Run npm run check
- [x] Start dev server and verify functionality
- [x] Test in browser (light/dark mode, mobile/tablet/desktop)
- [x] Commit changes

### The Fix

**File**: `crates/local-deployment/src/container.rs:394-406`

**Before** (problematic logic):
```rust
let should_start_next = if matches!(
    ctx.execution_process.run_reason,
    ExecutionProcessRunReason::CodingAgent
) {
    changes_committed  // Skipped cleanup if no changes!
} else {
    true
};

if should_start_next {
    container.try_start_next_action(&ctx).await;
} else {
    // Skipped cleanup AND finalized task prematurely
    container.finalize_task(...).await;
}
```

**After** (fixed logic):
```rust
tracing::info!(
    exec_id = %exec_id,
    changes_committed = changes_committed,
    run_reason = ?ctx.execution_process.run_reason,
    "Exit monitor: Process completed, proceeding to next action"
);

// Always proceed to next action (cleanup script) regardless of whether
// changes were committed. The agent may have done valuable work that
// doesn't involve file changes (e.g., browser testing, running tests).
if let Err(e) = container.try_start_next_action(&ctx).await {
    tracing::error!("Failed to start next action after completion: {}", e);
}
```

### Why This Works
- The cleanup script always runs, allowing proper task finalization
- Agents doing non-file-change work (browser testing, running tests) complete normally
- The `should_finalize()` check still occurs after cleanup script completes
- No premature finalization when `changes_committed=false`

### Testing Summary
| Test | Result |
|------|--------|
| `cargo test --workspace` | ✓ Pass |
| `cargo clippy --all` | ✓ Pass |
| `npm run check` | ✓ Pass |
| Desktop dark mode | ✓ Pass |
| Desktop light mode | ✓ Pass |
| Mobile viewport (375x812) | ✓ Pass |
| Tablet viewport (768x1024) | ✓ Pass |

## Summary

This investigation identified and fixed a bug where task attempts were prematurely finalized when the coding agent performed work that didn't result in file changes (e.g., browser testing with Playwright).

**Root Cause**: The exit monitor assumed that `changes_committed=false` meant the agent did nothing useful, skipping the cleanup script and finalizing immediately.

**Fix**: Removed the conditional logic that tied `should_start_next` to `changes_committed`. The cleanup script now always runs, allowing proper task finalization regardless of whether git changes were made.
