---
name: Add Remote Context to Session Error Endpoints
status: done
created: 2026-01-11T11:04:49Z
updated: 2026-01-11T11:45:00Z
depends_on: []
conflicts_with: []
---

# Task: Add Remote Context to Session Error Endpoints

## Description
Add `RemoteTaskAttemptContext` extraction to `has_session_error` and `fix_sessions` handlers. Return `false` for remote tasks on `has_session_error` (sessions are local-only), and proxy `fix_sessions` to the owning node.

## Acceptance Criteria
- [x] `has_session_error` handler signature includes `remote_ctx: Option<Extension<RemoteTaskAttemptContext>>`
- [x] `has_session_error` returns `false` for remote tasks without querying local database
- [x] `fix_sessions` handler signature includes `remote_ctx: Option<Extension<RemoteTaskAttemptContext>>`
- [x] `fix_sessions` proxies to owning node for remote tasks
- [x] Local behavior unchanged for both handlers
- [x] Build passes with `cargo check`
- [x] Clippy passes

## Technical Details
- **File**: `crates/server/src/routes/task_attempts/handlers/core.rs`
- Sessions are local-only - remote tasks have no local session
- `has_session_error`: Add early return with `false` when `remote_ctx.is_some()`
- `fix_sessions`: Use `check_remote_task_attempt_proxy` to proxy to owning node

## Code Changes Made

### has_session_error (line ~780)
```rust
pub async fn has_session_error(
    Extension(task_attempt): Extension<TaskAttempt>,
    remote_ctx: Option<Extension<RemoteTaskAttemptContext>>,  // ADDED
    State(deployment): State<DeploymentImpl>,
) -> Result<ResponseJson<ApiResponse<bool>>, ApiError> {
    // Sessions are local-only - remote tasks have no local session
    if remote_ctx.is_some() {
        return Ok(ResponseJson(ApiResponse::success(false)));
    }
    // ... existing local logic
}
```

### fix_sessions (line ~756)
```rust
pub async fn fix_sessions(
    Extension(task_attempt): Extension<TaskAttempt>,
    remote_ctx: Option<Extension<RemoteTaskAttemptContext>>,  // ADDED
    State(deployment): State<DeploymentImpl>,
) -> Result<ResponseJson<ApiResponse<FixSessionsResponse>>, ApiError> {
    // Proxy to owning node - this is a write operation
    if let Some(proxy_info) = check_remote_task_attempt_proxy(remote_ctx.as_ref().map(|e| &e.0))? {
        tracing::debug!(
            node_id = %proxy_info.node_id,
            shared_task_id = %proxy_info.target_id,
            "Proxying fix_sessions to remote node"
        );
        let path = format!("/task-attempts/by-task-id/{}/fix-sessions", proxy_info.target_id);
        let response: ApiResponse<FixSessionsResponse> = deployment
            .node_proxy_client()
            .proxy_post(&proxy_info.node_url, &path, &(), proxy_info.node_id)
            .await?;
        return Ok(ResponseJson(response));
    }
    // ... existing local logic
}
```

## Verification
- [x] `cargo check -p server` passes
- [x] `cargo clippy -p server -- -D warnings` passes
- [x] Local task attempt endpoints return correct responses
- [x] Pattern matches existing `stop_task_attempt_execution` and `get_task_attempt_children` implementations

## Definition of Done
- [x] Code implemented
- [x] `has_session_error` returns false for remote tasks
- [x] `fix_sessions` proxies for remote tasks
- [x] Build passes with `cargo check`
- [x] Clippy passes
