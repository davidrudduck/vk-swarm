---
name: Add get_template_by_name endpoint
status: open
created: 2026-01-19T12:00:00Z
updated: 2026-01-19T12:00:00Z
depends_on: ["001", "002"]
conflicts_with: []
model_hint: moderate
estimated_minutes: 30
---

# Task: Add get_template_by_name endpoint

## Goal
Create endpoint to fetch a single template by name, resolving from system -> swarm -> local priority.

## Context
This endpoint allows looking up a template by name. It searches in order:
1. System templates (exact name match or ID match)
2. Swarm templates (from Hive, if connected)
3. Local templates (from SQLite database)

The first match wins, so system templates take priority over swarm, which takes priority over local.

**File location**: `crates/server/src/routes/templates.rs`

**Required imports to add**:
- `axum::extract::Path` for path parameters

## Steps
1. Add `Path` to the axum imports (line 2)
2. Add `TemplateByNameParams` query params struct (after `TemplateSearchParams`)
3. Add `get_template_by_name` handler function
4. Update the router to add the new route

## Files to Modify
- `crates/server/src/routes/templates.rs` - Update import (line 2), add query struct, add handler, update router

## Code

### Step 1: Update axum imports (line 2)

Change:
```rust
use axum::{
    Extension, Json, Router,
    extract::{Query, State},
    middleware::from_fn_with_state,
    response::Json as ResponseJson,
    routing::{get, put},
};
```

To:
```rust
use axum::{
    Extension, Json, Router,
    extract::{Path, Query, State},
    middleware::from_fn_with_state,
    response::Json as ResponseJson,
    routing::{get, put},
};
```

### Step 2: Add query params struct

Add this after `TemplateSearchParams` struct (after the one with `search` field):

```rust
#[derive(Deserialize)]
pub struct TemplateByNameParams {
    /// Task ID for swarm context (optional)
    pub task_id: Option<Uuid>,
}
```

Also need to add `Uuid` to imports. Find the line with `use uuid::Uuid;` - if it doesn't exist, add it. Or add to the serde line: check current imports.

Actually, looking at the file, we need to add Uuid import. Add after line 10 (after `use serde::Deserialize;`):

```rust
use uuid::Uuid;
```

### Step 3: Add handler function

Add this function after `get_all_templates` (the function from Task 003):

```rust
/// GET /api/templates/by-name/{name} - Get template by name
pub async fn get_template_by_name(
    Path(name): Path<String>,
    Query(params): Query<TemplateByNameParams>,
    State(deployment): State<DeploymentImpl>,
) -> Result<ResponseJson<ApiResponse<UnifiedTemplate>>, ApiError> {
    let name_lower = name.to_lowercase();

    // 1. Check system templates first
    for t in SYSTEM_TEMPLATES {
        if t.name.to_lowercase() == name_lower || t.id == name {
            return Ok(ResponseJson(ApiResponse::success(UnifiedTemplate {
                id: t.id.to_string(),
                name: t.name.to_string(),
                content: t.content.to_string(),
                description: Some(t.description.to_string()),
                source: "system".to_string(),
                created_at: None,
                updated_at: None,
            })));
        }
    }

    // 2. Check swarm templates if connected
    if let Ok(remote_client) = deployment.remote_client() {
        if let Ok(swarm_templates) = remote_client.list_swarm_templates().await {
            for t in swarm_templates {
                if t.template_name.to_lowercase() == name_lower {
                    return Ok(ResponseJson(ApiResponse::success(UnifiedTemplate {
                        id: t.id.to_string(),
                        name: t.template_name,
                        content: t.content,
                        description: None,
                        source: "swarm".to_string(),
                        created_at: Some(t.created_at),
                        updated_at: Some(t.updated_at),
                    })));
                }
            }
        }
    }

    // 3. Check local templates
    let local_templates = Template::find_all(&deployment.db().pool).await?;
    for t in local_templates {
        if t.template_name.to_lowercase() == name_lower {
            return Ok(ResponseJson(ApiResponse::success(UnifiedTemplate {
                id: t.id.to_string(),
                name: t.template_name,
                content: t.content,
                description: None,
                source: "local".to_string(),
                created_at: Some(t.created_at),
                updated_at: Some(t.updated_at),
            })));
        }
    }

    Err(ApiError::NotFound(format!("Template '{}' not found", name)))
}
```

### Step 4: Update router

Update the `inner` Router in the `router` function:

Change (after Task 003's changes):
```rust
    let inner = Router::new()
        .route("/", get(get_templates).post(create_template))
        .route("/all", get(get_all_templates))
        .nest("/{template_id}", template_router);
```

To:
```rust
    let inner = Router::new()
        .route("/", get(get_templates).post(create_template))
        .route("/all", get(get_all_templates))
        .route("/by-name/{name}", get(get_template_by_name))
        .nest("/{template_id}", template_router);
```

## Verification
- [ ] Run `cargo check -p server` - should succeed with no errors
- [ ] System template lookup works by name (case-insensitive)
- [ ] System template lookup works by ID (exact match)
- [ ] Returns 404 `ApiError::NotFound` for unknown template

## Commit
`feat(server): add GET /api/templates/by-name/{name} endpoint`

## Notes
- The `params.task_id` is currently unused but included for future swarm context filtering
- Name matching is case-insensitive for all sources
- System templates can also be looked up by their ID (e.g., "system-bug-report")
- The search order (system -> swarm -> local) means system templates cannot be shadowed
