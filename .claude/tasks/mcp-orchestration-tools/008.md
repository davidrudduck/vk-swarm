---
name: Add MCP get_template tool
status: open
created: 2026-01-19T12:00:00Z
updated: 2026-01-19T12:00:00Z
depends_on: ["004", "007"]
conflicts_with: []
model_hint: simple
estimated_minutes: 15
---

# Task: Add MCP get_template tool

## Goal
Add MCP tool to get a specific template by name.

## Context
This tool allows AI orchestrators to fetch the full content of a specific template by name. It calls the `GET /api/templates/by-name/{name}` endpoint.

**File location**: `crates/server/src/mcp/task_server.rs`

The `urlencoding` crate is needed to encode the template name for the URL.

## Steps
1. Add request/response types after `ListTemplatesResponse` (from Task 007)
2. Add `get_template` tool in the impl block after `list_templates`

## Files to Modify
- `crates/server/src/mcp/task_server.rs` - Add types and tool
- May need to add `urlencoding` to Cargo.toml if not present

## Code

### Step 1: Check if urlencoding is available

First check if `urlencoding` is in `crates/server/Cargo.toml`. If not, add it:

```toml
urlencoding = "2"
```

### Step 2: Add request/response types

Add these after `ListTemplatesResponse`:

```rust
#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct GetTemplateRequest {
    #[schemars(description = "Template name to look up")]
    pub name: String,
    #[schemars(description = "Task ID for swarm context (optional)")]
    pub task_id: Option<Uuid>,
}

#[derive(Debug, Serialize, schemars::JsonSchema)]
pub struct GetTemplateResponse {
    pub id: String,
    pub name: String,
    pub content: String,
    pub description: Option<String>,
    pub source: String,
}
```

### Step 3: Add get_template tool

Add this after `list_templates`:

```rust
    #[tool(description = "Get a specific template by name.")]
    async fn get_template(
        &self,
        Parameters(GetTemplateRequest { name, task_id }): Parameters<GetTemplateRequest>,
    ) -> Result<CallToolResult, ErrorData> {
        let mut url = self.url(&format!(
            "/api/templates/by-name/{}",
            urlencoding::encode(&name)
        ));
        if let Some(tid) = task_id {
            url = format!("{}?task_id={}", url, tid);
        }

        #[derive(Deserialize)]
        struct UnifiedTemplate {
            id: String,
            name: String,
            content: String,
            description: Option<String>,
            source: String,
        }

        let template: UnifiedTemplate = match self.send_json(self.client.get(&url)).await {
            Ok(t) => t,
            Err(e) => return Ok(e),
        };

        let response = GetTemplateResponse {
            id: template.id,
            name: template.name,
            content: template.content,
            description: template.description,
            source: template.source,
        };

        TaskServer::success(&response)
    }
```

## Verification
- [ ] Run `cargo check -p server` - should succeed with no errors
- [ ] Tool returns template content when called with a valid name
- [ ] Tool returns error for unknown template name

## Commit
`feat(mcp): add get_template tool`

## Notes
- The `name` parameter is URL-encoded to handle special characters safely
- The `task_id` parameter is optional and included for future swarm context
- This tool returns the full `content` field, unlike `list_templates` which omits it
- The inner `UnifiedTemplate` struct is defined locally to avoid import dependencies
