---
name: Add MCP get_last_message tool
status: open
created: 2026-01-19T12:00:00Z
updated: 2026-01-19T12:00:00Z
depends_on: []
conflicts_with: []
model_hint: simple
estimated_minutes: 15
---

# Task: Add MCP get_last_message tool

## Goal
Add MCP tool to get recent log entries from an execution process.

## Context
This tool allows AI orchestrators to check what's happening in a running execution. It fetches the most recent log entries from the logs API.

The logs API endpoint is `GET /api/logs/{execution_process_id}` with query parameters for direction and limit.

**File location**: `crates/server/src/mcp/task_server.rs`

## Steps
1. Add request/response types after `SendTemplateRequest`
2. Add `get_last_message` tool

## Files to Modify
- `crates/server/src/mcp/task_server.rs` - Add types and tool

## Code

### Step 1: Add request/response types

Add these after `SendTemplateRequest`:

```rust
#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct GetLastMessageRequest {
    #[schemars(description = "Execution process ID")]
    pub execution_process_id: Uuid,
    #[schemars(description = "Number of entries to return (default 1, max 10)")]
    pub count: Option<i32>,
}

#[derive(Debug, Serialize, schemars::JsonSchema)]
pub struct LogEntrySummary {
    pub id: String,
    pub content: String,
    pub entry_type: String,
    pub created_at: String,
}

#[derive(Debug, Serialize, schemars::JsonSchema)]
pub struct GetLastMessageResponse {
    pub execution_process_id: String,
    pub entries: Vec<LogEntrySummary>,
    pub count: usize,
}
```

### Step 2: Add get_last_message tool

Add this after `send_template`:

```rust
    #[tool(description = "Get the most recent log entries from an execution process.")]
    async fn get_last_message(
        &self,
        Parameters(GetLastMessageRequest {
            execution_process_id,
            count,
        }): Parameters<GetLastMessageRequest>,
    ) -> Result<CallToolResult, ErrorData> {
        let limit = count.unwrap_or(1).min(10).max(1);
        let url = self.url(&format!(
            "/api/logs/{}?direction=backward&limit={}",
            execution_process_id, limit
        ));

        #[derive(Deserialize)]
        struct LogEntry {
            id: Uuid,
            content: String,
            entry_type: String,
            created_at: String,
        }

        #[derive(Deserialize)]
        struct LogsResponse {
            entries: Vec<LogEntry>,
        }

        let logs: LogsResponse = match self.send_json(self.client.get(&url)).await {
            Ok(l) => l,
            Err(e) => return Ok(e),
        };

        let entries: Vec<LogEntrySummary> = logs
            .entries
            .into_iter()
            .map(|e| LogEntrySummary {
                id: e.id.to_string(),
                content: e.content,
                entry_type: e.entry_type,
                created_at: e.created_at,
            })
            .collect();

        let response = GetLastMessageResponse {
            execution_process_id: execution_process_id.to_string(),
            count: entries.len(),
            entries,
        };

        TaskServer::success(&response)
    }
```

## Verification
- [ ] Run `cargo check -p server` - should succeed with no errors
- [ ] Tool returns recent log entries
- [ ] Count is clamped between 1 and 10

## Commit
`feat(mcp): add get_last_message tool`

## Notes
- The `direction=backward` parameter returns entries in reverse chronological order (newest first)
- The `count` parameter is clamped to 1-10 to prevent excessive data transfer
- The `entry_type` field indicates the type of log (e.g., "assistant", "user", "tool_use")
- The `content` field contains the actual message text
- This tool is useful for checking if an execution is stuck or what the AI is currently working on
