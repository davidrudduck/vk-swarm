---
name: Add MCP send_template tool
status: open
created: 2026-01-19T12:00:00Z
updated: 2026-01-19T12:00:00Z
depends_on: ["008", "009"]
conflicts_with: []
model_hint: simple
estimated_minutes: 15
---

# Task: Add MCP send_template tool

## Goal
Add MCP tool to send a template as a follow-up prompt.

## Context
This tool combines template fetching and follow-up sending into a single operation. It:
1. Fetches the template by name from the `/api/templates/by-name/{name}` endpoint
2. Sends the template content as a follow-up prompt

This is a convenience tool for orchestrators who want to apply a template to a running task.

**File location**: `crates/server/src/mcp/task_server.rs`

## Steps
1. Add request type after `SendFollowUpResponse`
2. Add `send_template` tool after `send_follow_up`

## Files to Modify
- `crates/server/src/mcp/task_server.rs` - Add type and tool

## Code

### Step 1: Add request type

Add this after `SendFollowUpResponse`:

```rust
#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct SendTemplateRequest {
    #[schemars(description = "Task ID to send template to")]
    pub task_id: Uuid,
    #[schemars(description = "Template name to send")]
    pub template_name: String,
    #[schemars(description = "Variant: DEFAULT, NO_CONTEXT, PLAN, APPROVALS")]
    pub variant: Option<String>,
}
```

### Step 2: Add send_template tool

Add this after `send_follow_up`:

```rust
    #[tool(description = "Send a template as follow-up prompt. Resolves template by name from system/swarm/local sources.")]
    async fn send_template(
        &self,
        Parameters(SendTemplateRequest {
            task_id,
            template_name,
            variant,
        }): Parameters<SendTemplateRequest>,
    ) -> Result<CallToolResult, ErrorData> {
        // 1. Fetch template content
        let template_url = self.url(&format!(
            "/api/templates/by-name/{}?task_id={}",
            urlencoding::encode(&template_name),
            task_id
        ));

        #[derive(Deserialize)]
        struct TemplateContent {
            content: String,
        }

        let template: TemplateContent = match self.send_json(self.client.get(&template_url)).await {
            Ok(t) => t,
            Err(e) => return Ok(e),
        };

        // 2. Send as follow-up
        let follow_up_url = self.url(&format!(
            "/api/task-attempts/by-task-id/{}/follow-up",
            task_id
        ));
        let payload = serde_json::json!({
            "prompt": template.content,
            "variant": variant,
        });

        #[derive(Deserialize)]
        struct FollowUpResult {
            id: Uuid,
            task_attempt_id: Uuid,
        }

        let result: FollowUpResult = match self
            .send_json(self.client.post(&follow_up_url).json(&payload))
            .await
        {
            Ok(r) => r,
            Err(e) => return Ok(e),
        };

        let response = SendFollowUpResponse {
            task_id: task_id.to_string(),
            attempt_id: result.task_attempt_id.to_string(),
            execution_process_id: result.id.to_string(),
        };

        TaskServer::success(&response)
    }
```

## Verification
- [ ] Run `cargo check -p server` - should succeed with no errors
- [ ] Tool resolves template then sends it
- [ ] Returns error if template not found
- [ ] Returns error if no active task attempt

## Commit
`feat(mcp): add send_template tool`

## Notes
- This tool reuses `SendFollowUpResponse` since the response structure is the same
- The template is resolved using the same priority: system -> swarm -> local
- The `task_id` is passed to the template lookup for swarm context
- If the template is not found, the first API call will return an error
- If no active attempt exists, the second API call will return an error
