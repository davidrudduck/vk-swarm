---
name: Add MCP send_follow_up tool
status: open
created: 2026-01-19T12:00:00Z
updated: 2026-01-19T12:00:00Z
depends_on: []
conflicts_with: []
model_hint: moderate
estimated_minutes: 30
---

# Task: Add MCP send_follow_up tool

## Goal
Add MCP tool to send a follow-up prompt to a task.

## Context
This tool allows AI orchestrators to send follow-up prompts to running task attempts. It calls the existing `POST /api/task-attempts/by-task-id/{task_id}/follow-up` endpoint.

The follow-up endpoint creates a new execution process for the task attempt and sends the prompt to the running AI agent.

**File location**: `crates/server/src/mcp/task_server.rs`

**Variants available**:
- `DEFAULT` - Normal follow-up with context
- `NO_CONTEXT` - Fresh context (useful for long sessions)
- `PLAN` - Planning mode
- `APPROVALS` - Approval mode

## Steps
1. Add Orchestration MCP Types section
2. Add `send_follow_up` tool

## Files to Modify
- `crates/server/src/mcp/task_server.rs` - Add types and tool

## Code

### Step 1: Add Orchestration MCP Types

Add this section after the Template MCP Types (after `GetTemplateResponse` from Task 008):

```rust
// ===== Orchestration MCP Types =====

#[derive(Debug, Deserialize, schemars::JsonSchema)]
pub struct SendFollowUpRequest {
    #[schemars(description = "Task ID to send follow-up to")]
    pub task_id: Uuid,
    #[schemars(description = "The follow-up prompt text")]
    pub prompt: String,
    #[schemars(description = "Variant: DEFAULT, NO_CONTEXT, PLAN, APPROVALS")]
    pub variant: Option<String>,
}

#[derive(Debug, Serialize, schemars::JsonSchema)]
pub struct SendFollowUpResponse {
    pub task_id: String,
    pub attempt_id: String,
    pub execution_process_id: String,
}
```

### Step 2: Add send_follow_up tool

Add this after the Template MCP Tools section:

```rust
    // ===== Orchestration MCP Tools =====

    #[tool(description = "Send a follow-up prompt to continue a task. Use variant='NO_CONTEXT' for fresh context.")]
    async fn send_follow_up(
        &self,
        Parameters(SendFollowUpRequest {
            task_id,
            prompt,
            variant,
        }): Parameters<SendFollowUpRequest>,
    ) -> Result<CallToolResult, ErrorData> {
        let url = self.url(&format!(
            "/api/task-attempts/by-task-id/{}/follow-up",
            task_id
        ));

        let payload = serde_json::json!({
            "prompt": prompt,
            "variant": variant,
        });

        #[derive(Deserialize)]
        struct FollowUpResult {
            id: Uuid,
            task_attempt_id: Uuid,
        }

        let result: FollowUpResult = match self
            .send_json(self.client.post(&url).json(&payload))
            .await
        {
            Ok(r) => r,
            Err(e) => return Ok(e),
        };

        let response = SendFollowUpResponse {
            task_id: task_id.to_string(),
            attempt_id: result.task_attempt_id.to_string(),
            execution_process_id: result.id.to_string(),
        };

        TaskServer::success(&response)
    }
```

## Verification
- [ ] Run `cargo check -p server` - should succeed with no errors
- [ ] Tool description is clear for orchestrators
- [ ] Tool sends POST request to correct endpoint

## Commit
`feat(mcp): add send_follow_up tool`

## Notes
- The `task_id` parameter identifies which task to send the follow-up to
- The endpoint finds the latest task attempt for that task automatically
- The `variant` parameter is optional and defaults to `DEFAULT`
- The response includes the new `execution_process_id` for tracking the follow-up
- If no active attempt exists, the backend will return an error
