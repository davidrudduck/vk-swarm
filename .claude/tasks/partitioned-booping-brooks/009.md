---
name: Implement migration fallback in get_logs_paginated
status: completed
created: 2026-01-12T08:02:12Z
updated: 2026-01-13T11:14:00Z
depends_on: [008]
conflicts_with: [008]
---

# Task: Implement migration fallback in get_logs_paginated

## Description
Modify `get_logs_paginated` to trigger on-demand migration when log_entries is empty but legacy logs exist.

## Acceptance Criteria
- [x] Check if paginated result is empty with total_count of 0
- [x] If empty, check has_legacy_logs
- [x] If legacy logs exist, trigger migration
- [x] Retry fetch after successful migration
- [x] Test from task 007 passes

## Technical Details
- Location: `crates/services/src/services/unified_logs.rs` in `get_logs_paginated`
- Add check after initial fetch
- Use log_migration::migrate_execution_logs
- Handle migration errors gracefully (log and continue)
- Add tracing::info for migration trigger

## Code
```rust
if paginated.entries.is_empty() && paginated.total_count == Some(0) {
    if self.has_legacy_logs(execution_id).await.unwrap_or(false) {
        tracing::info!(execution_id = %execution_id, "Triggering on-demand log migration");
        if let Err(e) = log_migration::migrate_execution_logs(&self.pool, execution_id).await {
            tracing::warn!(execution_id = %execution_id, error = %e, "On-demand migration failed");
        } else {
            // Retry fetch
            let retry = DbLogEntry::find_paginated(...).await?;
            return Ok(retry.to_paginated_logs());
        }
    }
}
```

## Dependencies
- [x] Task 008 complete

## Effort Estimate
- Size: S
- Hours: 1

## Definition of Done
- [x] Code implemented
- [x] Test from task 007 passes
- [x] No regressions in existing tests
