---
title: Database Synchronization
description: How data synchronizes between local nodes and the central hive
---

# Database Synchronization

Vibe Kanban uses multiple synchronization mechanisms to keep local nodes and the central hive in sync. This document explains what data flows where and how.

## Synchronization Methods

The system uses three complementary sync methods:

| Method | Direction | Use Case | Status |
|--------|-----------|----------|--------|
| **ElectricSQL** | Bidirectional | Task data, projects, nodes | Modern (recommended) |
| **WebSocket** | Bidirectional | Events, logs, heartbeats | Active |
| **REST API** | Pull only | Node cache, activity polling | Legacy (deprecated) |

## Architecture Diagram

```text
┌─────────────────────────────────────────────────────────────────────┐
│                         HIVE (PostgreSQL)                            │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                    Logical Replication (WAL)                  │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                               │                                      │
│                               ▼                                      │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                       ElectricSQL                             │   │
│  │              (Shape API: /v1/shape?table=...)                 │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                               │                                      │
└───────────────────────────────┼──────────────────────────────────────┘
                                │
              ┌─────────────────┼─────────────────┐
              │ HTTP (NDJSON)   │   WebSocket     │
              │                 │                 │
              ▼                 ▼                 ▼
┌──────────────────┐   ┌──────────────────┐   ┌──────────────────┐
│   NODE: Mac      │   │   NODE: Linux    │   │   NODE: Windows  │
│                  │   │                  │   │                  │
│  ElectricSync ◄──┼───┼──► Tasks         │   │                  │
│  HiveClient  ◄───┼───┼──► Events        │   │                  │
│                  │   │                  │   │                  │
│  [SQLite DB]     │   │  [SQLite DB]     │   │  [SQLite DB]     │
└──────────────────┘   └──────────────────┘   └──────────────────┘
```

---

## ElectricSQL Sync

ElectricSQL provides real-time, bidirectional sync using PostgreSQL's logical replication.

### How It Works

1. PostgreSQL writes changes to WAL (Write-Ahead Log)
2. ElectricSQL reads WAL via logical replication
3. Exposes changes via Shape API (`/v1/shape?table=...`)
4. Nodes poll Shape API and receive NDJSON stream of operations
5. Local SQLite updated with insert/update/delete operations

### Synced Tables

| Hive Table | Local Representation | Direction |
|------------|---------------------|-----------|
| `shared_tasks` | `tasks` (via `shared_task_id`) | Bidirectional |
| `projects` | `projects` (via `remote_project_id`) | Bidirectional |
| `nodes` | `cached_nodes` | Hive → Node |
| `node_projects` | `cached_node_projects` | Hive → Node |
| `node_task_assignments` | Task status | Hive → Node |

### ElectricSQL Shape Configuration

```rust
// Example: Sync tasks for a specific project
let config = ShapeConfig {
    base_url: "https://electric.example.com".to_string(),
    table: "shared_tasks".to_string(),
    where_clause: Some(format!(r#""project_id" = '{}'"#, project_id)),
    columns: None,  // All columns
};
```

### Control Messages

| Message | Meaning |
|---------|---------|
| `UpToDate` | Sync is current, no pending changes |
| `MustRefetch` | Full resync required (schema change or gap) |

---

## WebSocket Communication

WebSocket provides real-time bidirectional messaging for events that require immediate delivery.

### Connection Management

| Parameter | Value |
|-----------|-------|
| Heartbeat Interval | 30 seconds |
| Reconnect Delay | 5 seconds (initial) |
| Max Reconnect Delay | 60 seconds (exponential backoff) |
| URL Format | `wss://hive.example.com/ws/node` |

### Message Types: Node → Hive

| Message | Purpose | Data |
|---------|---------|------|
| `Auth` | Initial authentication | API key, node capabilities |
| `Heartbeat` | Health check | Node status, active tasks |
| `TaskStatus` | Execution state change | Task ID, status, local IDs |
| `TaskOutput` | Log streaming | Stdout/stderr content |
| `TaskProgress` | Execution milestone | Event type, message, metadata |
| `LinkProject` | Register project | Local project ID, git path |
| `UnlinkProject` | Deregister project | Project ID |
| `AttemptSync` | Sync task attempt | Attempt ID, executor, branch, timestamps |
| `ExecutionSync` | Sync execution process | Process ID, status, commits, exit code |
| `LogsBatch` | Batch log entries | Array of log entries with execution_process_id |
| `LabelSync` | Sync label to hive | Label ID, name, icon, color, version |
| `TaskSync` | Sync local task to hive | Task details for tasks created locally |

### Message Types: Hive → Node

| Message | Purpose | Data |
|---------|---------|------|
| `AuthResult` | Confirm authentication | Node ID, linked projects |
| `TaskAssign` | Dispatch task | Task details, project info |
| `TaskCancel` | Cancel execution | Task ID |
| `ProjectSync` | New project link | Project info from another node |
| `NodeRemoved` | Node was removed | - |
| `StatusRequest` | Request status | - |
| `HeartbeatAck` | Acknowledge heartbeat | - |
| `LabelSync` | Broadcast label from another node | Shared label ID, name, icon, color, version |
| `TaskSyncResponse` | Confirm task sync | Task ID, shared_task_id |

### Task Assignment Flow

```text
1. HIVE: Create assignment in PostgreSQL
   INSERT INTO node_task_assignments (task_id, node_id, ...)

2. HIVE: Send WebSocket message
   TaskAssign { task_id, project_id, title, description, ... }

3. NODE: Receive and create local task
   INSERT INTO tasks (shared_task_id = task_id, ...)
   INSERT INTO task_attempts (...)

4. NODE: Start execution
   TaskStatus { task_id, status: "running", local_task_id, local_attempt_id }

5. NODE: Stream output
   TaskOutput { task_id, output_type: "stdout", content: "..." }

6. NODE: Report progress
   TaskProgress { task_id, event_type: "committed", message: "Added feature X" }

7. NODE: Complete execution
   TaskStatus { task_id, status: "completed" }

8. HIVE: Update shared task
   UPDATE shared_tasks SET status = 'done' WHERE id = task_id
```

---

## What Is Synchronized

### Fully Synchronized (Both Databases)

| Entity | SQLite Table | PostgreSQL Table | Sync Method |
|--------|-------------|-----------------|-------------|
| Tasks | `tasks` | `shared_tasks` | ElectricSQL |
| Projects | `projects` | `projects` | ElectricSQL |
| Task Status | `tasks.status` | `shared_tasks.status` | WebSocket + Electric |
| Assignee | `tasks.remote_assignee_*` | `shared_tasks.assignee_user_id` | ElectricSQL |

### Synchronized One-Way (Hive → Node)

| Entity | SQLite Table | PostgreSQL Table | Sync Method |
|--------|-------------|-----------------|-------------|
| Node Registry | `cached_nodes` | `nodes` | REST API (legacy) → ElectricSQL |
| Node-Project Links | `cached_node_projects` | `node_projects` | REST API (legacy) → ElectricSQL |
| Task Assignments | (inline in task) | `node_task_assignments` | WebSocket |

### Synchronized One-Way (Node → Hive)

| Entity | SQLite Table | PostgreSQL Table | Sync Method |
|--------|-------------|-----------------|-------------|
| Execution Logs | `log_entries` | `node_task_output_logs` | WebSocket (`LogsBatch`) |
| Progress Events | (inline in process) | `node_task_progress_events` | WebSocket |
| Node Heartbeat | - | `nodes.last_heartbeat_at` | WebSocket |
| Task Attempts | `task_attempts` | `node_task_attempts` | WebSocket (`AttemptSync`) |
| Execution Processes | `execution_processes` | `node_execution_processes` | WebSocket (`ExecutionSync`) |

### Synchronized Bidirectionally (via WebSocket)

| Entity | SQLite Table | PostgreSQL Table | Sync Method |
|--------|-------------|-----------------|-------------|
| Labels | `labels` | `labels` | WebSocket (`LabelSync`) |
| Task Labels | `task_labels` | `shared_task_labels` | REST API (on task update) |
| Local Tasks | `tasks` | `shared_tasks` | WebSocket (`TaskSync` + `TaskSyncResponse`) |

### Not Synchronized (Local Only)

| Entity | SQLite Table | Reason |
|--------|-------------|--------|
| Executor Sessions | `executor_sessions` | Claude/agent session IDs |
| Merges | `merges` | PR/merge tracking (local git state) |
| Templates | `templates` | Local UI configuration |
| Task Variables | `task_variables` | Task-specific configuration |
| Activity Dismissals | `activity_dismissals` | UI state |
| Images | `images` | Task attachments |

### Not Synchronized (Hive Only)

| Entity | PostgreSQL Table | Reason |
|--------|-----------------|--------|
| Organizations | `organizations` | Multi-tenant container |
| Users | `users` | Authentication only |
| OAuth Accounts | `oauth_accounts` | Authentication only |
| Auth Sessions | `auth_sessions` | Authentication only |
| Activity Feed | `activity` | Event history (nodes poll as needed) |
| Invitations | `organization_invitations` | UI workflow |

---

## Conflict Resolution

### Version-Based Optimistic Locking

The `shared_tasks` table uses a `version` field for conflict detection:

```sql
-- Hive: Increment version on update
UPDATE shared_tasks
SET status = 'done', version = version + 1, updated_at = NOW()
WHERE id = $1 AND version = $2;

-- If rows affected = 0, concurrent modification detected
```

### Last-Write-Wins

For most fields, the last write wins. The `updated_at` timestamp determines recency.

### Activity-At vs Updated-At

The `activity_at` field tracks significant changes (status, execution) separately from metadata updates:

- **`updated_at`**: Any field change
- **`activity_at`**: Status change, execution start/complete

This allows UI sorting by "real" activity without noise from metadata updates.

---

## Node-to-Node Communication

When a node needs to access a project hosted on another node:

### Direct Connection

If the remote node has a `public_url`:

1. Source node generates JWT token with proxy claims
2. HTTP request sent directly to remote node's API
3. Remote node validates JWT and processes request

```rust
// JWT claims for node proxy
struct ProxyTokenClaims {
    sub: String,       // Source node ID
    node_id: String,   // Target node ID
    iat: i64,          // Issued at
    exp: i64,          // Expiration (5 min TTL)
    aud: String,       // "node_proxy"
}
```

### Hive Relay Fallback

If direct connection fails or `public_url` is not set:

1. Request goes through hive
2. Hive relays to target node via WebSocket
3. Response relayed back

---

## Sync Service Locations

| Service | Crate | File | Purpose |
|---------|-------|------|---------|
| ElectricSync | services | `electric_sync.rs` | Shape API client |
| ElectricTaskSync | services | `electric_task_sync.rs` | Task-specific sync |
| HiveClient | services | `hive_client.rs` | WebSocket connection |
| HiveSyncService | services | `hive_sync.rs` | Background entity sync |
| NodeRunner | services | `node_runner.rs` | Task assignment handling |
| NodeProxyClient | services | `node_proxy_client.rs` | Node-to-node HTTP |
| RemoteClient | services | `remote_client.rs` | REST API client |
| LabelPublisher | services | `share/label_publisher.rs` | Label sync to/from Hive |
| NodeCache | services | `node_cache.rs` | Legacy node polling |

---

## Background Sync Service (HiveSyncService)

The `HiveSyncService` runs in the background to sync task attempts, execution processes, and log entries to the Hive. It is spawned automatically when a node connects to the Hive.

### How It Works

1. **Sync Loop**: Runs every 5 seconds (configurable)
2. **Tracking**: Each entity has a `hive_synced_at` column
3. **Offline-First**: Queues sync until Hive connection is available
4. **Batch Processing**: Log entries are batched for efficiency

### Sync Flow

```text
1. HiveSyncService spawned when NodeRunner starts

2. Every 5 seconds:
   a. Find unsynced task_attempts (hive_synced_at IS NULL)
   b. Send AttemptSync message for each
   c. Mark as synced (set hive_synced_at)

   d. Find unsynced execution_processes
   e. Send ExecutionSync message for each
   f. Mark as synced

   g. Find unsynced log_entries (batched)
   h. Send LogsBatch message
   i. Mark batch as synced

3. If Hive disconnects:
   - Sync pauses
   - Entities remain unsynced (hive_synced_at = NULL)
   - Resume when connection restored
```

### Database Columns

```sql
-- SQLite: Sync tracking columns (added via migration)
ALTER TABLE task_attempts ADD COLUMN hive_synced_at TEXT;
ALTER TABLE execution_processes ADD COLUMN hive_synced_at TEXT;
ALTER TABLE log_entries ADD COLUMN hive_synced_at TEXT;

-- Partial indexes for efficient unsynced queries
CREATE INDEX idx_task_attempts_unsynced
ON task_attempts(id) WHERE hive_synced_at IS NULL;
```

### Configuration

The sync interval can be configured when creating the service:

```rust
let sync_service = HiveSyncService::new(
    db.clone(),
    hive_client.clone(),
    Duration::from_secs(5), // Sync interval
);
```

---

## Label Synchronization

Labels sync bidirectionally between nodes via the hive using WebSocket messages.

### How Label Sync Works

1. **Node creates/updates label**: A label is created or modified locally
2. **Sync service detects change**: `HiveSyncService` finds labels with `shared_label_id IS NULL` (new) or `updated_at > synced_at` (modified)
3. **Send to hive**: `LabelSync` message sent with label details and version
4. **Hive stores label**: Hive upserts label with version-based conflict resolution
5. **Broadcast to other nodes**: Hive sends `LabelSync` to all other nodes in the organization
6. **Other nodes receive**: Each node creates/updates their local label copy

### Version-Based Conflict Resolution

Labels use a `version` field for conflict detection:

```sql
-- Updates only apply if incoming version > existing version
UPDATE labels
SET name = $1, color = $2, version = $3
WHERE id = $4 AND version < $3;
```

This ensures that older updates don't overwrite newer data in multi-node environments.

### Label Fields Synced

| Field | Description |
|-------|-------------|
| `shared_label_id` | UUID linking local to hive label |
| `name` | Label display name |
| `icon` | Lucide icon name |
| `color` | Hex color code |
| `version` | Incrementing version for conflict resolution |
| `project_id` | Project scope (null for org-wide labels) |

---

## Local Task Synchronization

Tasks created locally on a node are synced to the hive so their execution attempts can be properly tracked.

### How Task Sync Works

1. **Task created locally**: User creates a task on a node
2. **Task executed**: User starts a task attempt
3. **Sync service detects**: `HiveSyncService` finds tasks needing sync:
   - `shared_task_id IS NULL` (not yet synced)
   - `is_remote = 0` (locally created)
   - Project has `remote_project_id` (linked to hive)
   - Has unsynced attempts
4. **Send to hive**: `TaskSync` message sent with task details
5. **Hive creates shared task**: Hive creates entry in `shared_tasks` table
6. **Response received**: Node receives `TaskSyncResponse` with `shared_task_id`
7. **Local update**: Node updates local task with `shared_task_id`
8. **Attempts sync**: Now `AttemptSync` can proceed (requires valid `shared_task_id`)

### The `is_remote` Flag

Tasks have an `is_remote` flag that determines editability:

| `is_remote` | Source | Editable | Description |
|-------------|--------|----------|-------------|
| `0` | Local | Yes | Task created on this node |
| `1` | Remote | No | Task from hive or another node |

**Important**: When tasks are synced from the hive, the system preserves `is_remote = 0` for tasks that belong to locally-owned projects. This ensures users can still edit their own tasks after sync.

### Sync Order

The `HiveSyncService` syncs entities in this order:

1. **Tasks** (`sync_tasks()`) - Ensure local tasks have `shared_task_id`
2. **Labels** (`sync_labels()`) - Sync label definitions
3. **Attempts** (`sync_attempts()`) - Sync task attempts (requires `shared_task_id`)
4. **Executions** (`sync_executions()`) - Sync execution processes
5. **Logs** (`sync_logs()`) - Batch sync log entries

---

## Monitoring and Debugging

### Check Sync Status

```sql
-- SQLite: Check last sync time for a project
SELECT remote_last_synced_at FROM projects WHERE id = ?;

-- SQLite: Check task sync state
SELECT shared_task_id, remote_version, remote_last_synced_at
FROM tasks WHERE is_remote = 1;
```

### WebSocket Connection State

The `HiveClient` logs connection events:

```text
INFO  Connected to hive at wss://...
INFO  Authenticated as node abc123
WARN  Connection lost, reconnecting in 5s
ERROR Failed to reconnect after 5 attempts
```

### ElectricSQL Shape Polling

Shape API returns offset for pagination:

```text
GET /v1/shape?table=shared_tasks&offset=0_0
→ Returns NDJSON with operations
→ Last line contains new offset: 1234_5678
```

---

## Environment Configuration

| Variable | Purpose | Example |
|----------|---------|---------|
| `VK_HIVE_URL` | WebSocket URL for hive | `wss://hive.example.com` |
| `VK_NODE_API_KEY` | Authentication key | `vk_abc123...` |
| `VK_NODE_NAME` | Human-readable node name | `Mac Studio` |
| `VK_NODE_PUBLIC_URL` | Direct connection URL | `http://192.168.1.50:3000` |
| `VK_CONNECTION_TOKEN_SECRET` | JWT secret for node-to-node | Base64 encoded secret |

## Related Documentation

- [Database Overview](./database-overview.mdx) - Architecture overview
- [SQLite Local Schema](./sqlite-local-schema.mdx) - Local node database schema
- [PostgreSQL Hive Schema](./postgresql-hive-schema.mdx) - Central hive schema
- [Swarm/Hive Setup Guide](../../swarm-hive-setup.mdx) - Configuration guide
