---
title: "Swarm Sync Architecture"
description: "Technical documentation of the swarm synchronization data model and sync flows"
---

This document describes the technical architecture of swarm synchronization between nodes and the hive server.

## Overview

The swarm sync system enables distributed task management across multiple Vibe Kanban nodes. Each node maintains its own local data (SQLite database) while synchronizing tasks and metadata through a central Hive server.

## Sync Flow

### 1. Node Registration

When a node first connects to the Hive:

1. **Node Registration**: The node connects via WebSocket to the Hive server using its API key (`VK_NODE_API_KEY`)
2. **Authentication**: Node presents its credentials to prove ownership of its projects
3. **Project Discovery**: Hive shares swarm projects (from other nodes) with this node
4. **Local Project Linking**: Node can link its local projects to swarm projects

```text
Node A (Local)           Hive (Central)            Node B (Local)
┌─────────────┐          ┌───────────────┐          ┌─────────────┐
│ SQLite DB   │◄────────►│ PostgreSQL DB  │◄────────►│ SQLite DB   │
│ - Projects  │          │ - Orgs         │          │ - Projects  │
│ - Tasks     │          │ - Users        │          │ - Tasks     │
│ - Logs      │          │ - Swarm Pjs    │          │ - Logs      │
└─────────────┘          └───────────────┘          └─────────────┘
```

### 2. Task Synchronization

Tasks flow between nodes in the following manner:

1. **Task Creation on Node A**:
   - Task is stored locally in SQLite
   - If project is linked to swarm, task gets a `shared_task_id` UUID
   - Task is published to Hive via WebSocket

2. **Task Distribution**:
   - Hive receives task from Node A
   - Hive looks up which other nodes have this project linked
   - Hive assigns task to appropriate node(s) based on:
     - Node availability (online status)
     - Load balancing
     - Explicit node assignment

3. **Task Execution on Node B**:
   - Node B receives task via WebSocket
   - Task is stored locally with original `shared_task_id`
   - Node B tracks progress and updates Hive in real-time

4. **Sync Back to Hive**:
   - When Node B completes task (or makes progress)
   - Updates are sent to Hive
   - Hive propagates updates to all nodes with this project linked
   - Node A receives updates showing task completed

### 3. Conflict Resolution

When the same task is modified on multiple nodes simultaneously:

- **Last Write Wins**: The node that writes changes to Hive last wins
- **Version Detection**: Each task update includes a timestamp
- **Notification**: Other nodes receive conflict notifications and can merge/reject changes

## Data Model Overview

The swarm architecture uses a hub-and-spoke model where the hive (PostgreSQL) serves as the central source of truth, and nodes (SQLite) maintain local caches with bidirectional sync.

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                              HIVE (PostgreSQL)                          │
├─────────────────────────────────────────────────────────────────────────┤
│  swarm_projects          │  swarm_labels           │  swarm_templates   │
│  ├─ id                   │  ├─ id                  │  ├─ id             │
│  ├─ organization_id      │  ├─ organization_id     │  ├─ organization_id│
│  ├─ name                 │  ├─ name, icon, color   │  ├─ name, content  │
│  └─ created_at           │  └─ created_at          │  └─ created_at     │
│                          │                         │                    │
│  swarm_project_nodes     │  swarm_tasks            │  execution_logs    │
│  ├─ swarm_project_id     │  ├─ swarm_project_id    │  ├─ assignment_id  │
│  ├─ node_id              │  ├─ title, description  │  ├─ output_type    │
│  ├─ local_project_id     │  ├─ status, version     │  ├─ content        │
│  ├─ git_repo_path        │  └─ created_at          │  └─ timestamp      │
│  └─ os_type              │                         │                    │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    │ WebSocket     │  WebSocket    │ WebSocket
                    ▼               ▼               ▼
┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐
│    NODE A (SQLite)  │  │    NODE B (SQLite)  │  │    NODE C (SQLite)  │
├─────────────────────┤  ├─────────────────────┤  ├─────────────────────┤
│ projects            │  │ projects            │  │ projects            │
│ ├─ swarm_project_id │  │ ├─ swarm_project_id │  │ ├─ swarm_project_id │
│ └─ (NULL = local)   │  │ └─ (NULL = local)   │  │ └─ (NULL = local)   │
│                     │  │                     │  │                     │
│ tasks (CACHE)       │  │ tasks (CACHE)       │  │ tasks (CACHE)       │
│ ├─ swarm_task_id    │  │ ├─ swarm_task_id    │  │ ├─ swarm_task_id    │
│ └─ (NULL = local)   │  │ └─ (NULL = local)   │  │ └─ (NULL = local)   │
│                     │  │                     │  │                     │
│ labels              │  │ labels              │  │ labels              │
│ ├─ swarm_label_id   │  │ ├─ swarm_label_id   │  │ ├─ swarm_label_id   │
│ └─ (NULL = local)   │  │ └─ (NULL = local)   │  │ └─ (NULL = local)   │
└─────────────────────┘  └─────────────────────┘  └─────────────────────┘
```

## Entity Linking States

Entities on nodes have a linking state determined by their `swarm_*_id` field:

| Entity | `swarm_*_id = NULL` | `swarm_*_id = UUID` |
|--------|---------------------|---------------------|
| Project | Local only, not shared | Linked to swarm project |
| Task | Local only (in unlinked project) | Swarm-owned, synced |
| Label | Local only, cannot be used in swarm tasks | Available across all nodes |
| Template | Local only | Available across all nodes |

## Unlink Operation

When a project is unlinked from the swarm, the system performs an atomic transaction to ensure data consistency. This operation clears all swarm-related state for the project and its associated tasks.

### Transaction Sequence

The unlink operation wraps three database operations in a single transaction (implemented in `crates/server/src/routes/projects/handlers/swarm.rs:25-46`):

```rust
// Begin transaction
let mut tx = pool.begin().await?;

// 1. Clear shared_task_id from all tasks in this project
Task::clear_all_shared_task_ids_for_project_tx(&mut *tx, project_id).await?;

// 2. Clear hive_synced_at from all task attempts for this project
TaskAttempt::clear_hive_sync_for_project_tx(&mut *tx, project_id).await?;

// 3. Clear remote_project_id from the project
Project::set_remote_project_id_tx(&mut *tx, project_id, None).await?;

// Commit all changes atomically
tx.commit().await?;
```

### Atomic Guarantees

The transaction ensures that:
- **All three operations succeed together** - If any operation fails, all changes are rolled back
- **No partial state** - The project is never in an inconsistent state where tasks are unlinked but the project still has a `remote_project_id`
- **Immediate consistency** - Once the transaction commits, all sync state is cleared and the project is fully local

### Rollback Behaviour

If any of the three operations fails:
1. The transaction is automatically rolled back
2. All database changes are reverted
3. An error response is returned to the client
4. The project remains in its original linked state

Common failure scenarios:
- Database lock timeout
- Foreign key constraint violation
- Network interruption during transaction

### Performance Optimisation: Composite Index

To efficiently query orphaned tasks during sync health checks, a composite index is created on the `tasks` table:

```sql
CREATE INDEX IF NOT EXISTS idx_tasks_project_shared
ON tasks(project_id, shared_task_id)
WHERE shared_task_id IS NOT NULL;
```

**Index Purpose:**
- Optimises queries that filter by `project_id` and check for non-null `shared_task_id`
- Used by `count_orphaned_for_project()` to quickly find tasks with stale sync state
- Partial index reduces storage by only indexing rows where `shared_task_id IS NOT NULL`

**Performance Impact:**
- Without index: Full table scan of all tasks (O(n))
- With index: Targeted lookup of relevant tasks (O(log n))
- Particularly beneficial for projects with many tasks

**Related Code:**
- Transaction implementation: `crates/server/src/routes/projects/handlers/swarm.rs:25-46`
- Task cleanup function: `crates/db/src/models/task/sync.rs` (`clear_all_shared_task_ids_for_project_tx`)
- TaskAttempt cleanup: `crates/db/src/models/task_attempt.rs` (`clear_hive_sync_for_project_tx`)
- Project update: `crates/db/src/models/project/sync.rs` (`set_remote_project_id_tx`)
- Index migration: `crates/db/migrations/20260116120000_add_tasks_project_shared_index.sql`

## Hive Database Schema

### swarm_projects

Central registry of shared projects.

```sql
CREATE TABLE swarm_projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(organization_id, name)
);
```

### swarm_project_nodes

Junction table linking swarm projects to node projects.

```sql
CREATE TABLE swarm_project_nodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  swarm_project_id UUID NOT NULL REFERENCES swarm_projects(id) ON DELETE CASCADE,
  node_id UUID NOT NULL REFERENCES nodes(id) ON DELETE CASCADE,
  local_project_id UUID NOT NULL,
  git_repo_path TEXT NOT NULL,
  os_type TEXT,
  linked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(swarm_project_id, node_id, local_project_id)
);
```

### swarm_tasks

Shared tasks owned by the hive.

```sql
CREATE TABLE swarm_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  swarm_project_id UUID NOT NULL REFERENCES swarm_projects(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL DEFAULT 'todo',
  priority INTEGER DEFAULT 0,
  version BIGINT NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### labels (Hive)

Organization-global labels.

```sql
CREATE TABLE labels (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  name TEXT NOT NULL,
  color TEXT NOT NULL DEFAULT '#6366f1',
  icon TEXT,
  version BIGINT NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(organization_id, name)
);
```

### swarm_templates

Organization-global task templates.

```sql
CREATE TABLE swarm_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id),
  name TEXT NOT NULL,
  content TEXT NOT NULL,
  version BIGINT NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(organization_id, name)
);
```

## Node Database Schema Additions

### projects

Extended with swarm linking fields:

```sql
ALTER TABLE projects ADD COLUMN swarm_project_id TEXT;
-- NULL = local project, UUID = linked to swarm project
```

### tasks

Extended with swarm linking and sync tracking:

```sql
ALTER TABLE tasks ADD COLUMN shared_task_id TEXT;
-- NULL shared_task_id = local task, UUID = linked to hive task
-- ElectricSQL syncs tasks directly to this table via shared_task_id
```

> **Note**: The legacy `shared_tasks` cache table has been removed. ElectricSQL now syncs
> tasks directly to the `tasks` table using the `shared_task_id` foreign key for
> upsert conflict resolution.

### labels

Extended with swarm linking:

```sql
ALTER TABLE labels ADD COLUMN swarm_label_id TEXT;
ALTER TABLE labels ADD COLUMN version INTEGER NOT NULL DEFAULT 1;
ALTER TABLE labels ADD COLUMN synced_at TEXT;
```

## Sync Protocols

### WebSocket Message Types

Nodes and hive communicate via WebSocket with these message types:

```rust
enum NodeToHive {
    // Connection
    Authenticate { api_key: String },
    Heartbeat,

    // Project linking
    LinkProject { swarm_project_id: Uuid, local_project_id: Uuid, git_path: String },
    UnlinkProject { swarm_project_id: Uuid, local_project_id: Uuid },

    // Task sync
    TaskCreated { task: SwarmTask },
    TaskUpdated { task: SwarmTask },
    TaskDeleted { task_id: Uuid },

    // Label sync
    LabelSync { labels: Vec<Label> },

    // Execution sync
    AttemptCreated { attempt: TaskAttempt },
    AttemptUpdated { attempt: TaskAttempt },
    LogBatch { logs: Vec<LogEntry> },
}

enum HiveToNode {
    // Connection
    Authenticated { node_id: Uuid },
    Error { message: String },

    // Task broadcast
    TaskCreated { task: SwarmTask },
    TaskUpdated { task: SwarmTask },
    TaskDeleted { task_id: Uuid },

    // Label broadcast
    LabelUpdated { label: Label },
    LabelDeleted { label_id: Uuid },

    // Template broadcast
    TemplateUpdated { template: SwarmTemplate },
    TemplateDeleted { template_id: Uuid },

    // Sync state
    SyncState { projects: Vec<ProjectLink> },
}
```

### Task Sync Flow

**Create Task (Node → Hive → All Nodes)**

```text
┌──────────┐         ┌──────────┐         ┌──────────┐
│  Node A  │         │   Hive   │         │  Node B  │
└────┬─────┘         └────┬─────┘         └────┬─────┘
     │                    │                    │
     │ TaskCreated(task)  │                    │
     │───────────────────►│                    │
     │                    │                    │
     │   Ack(swarm_id)    │                    │
     │◄───────────────────│                    │
     │                    │                    │
     │                    │ TaskCreated(task)  │
     │                    │───────────────────►│
     │                    │                    │
```

**Update Task (Conflict Resolution)**

```text
┌──────────┐         ┌──────────┐
│  Node A  │         │   Hive   │
└────┬─────┘         └────┬─────┘
     │                    │
     │ TaskUpdated        │
     │ (version: 3)       │
     │───────────────────►│
     │                    │
     │   IF hive.version  │
     │      == 3          │
     │   Accept, version  │
     │      = 4           │
     │◄───────────────────│
     │                    │
     │   ELSE             │
     │   Conflict, send   │
     │   current version  │
     │◄───────────────────│
```

### Label Sync Flow

Labels sync bidirectionally with version tracking:

1. Node creates/updates label locally
2. Node sends `LabelSync` message with local labels
3. Hive compares versions
4. Hive updates its records (higher version wins)
5. Hive broadcasts updated labels to all nodes
6. Nodes update their local cache

### Execution Log Sync

Logs sync via background service (HiveSyncService):

```rust
// Every 5 seconds
async fn sync_to_hive() {
    // 1. Find unsynced task attempts
    let attempts = db.find_attempts_where(hive_synced_at IS NULL);

    // 2. Sync attempts to hive
    for attempt in attempts {
        hive.sync_attempt(attempt).await?;
        db.mark_attempt_synced(attempt.id).await?;
    }

    // 3. Find unsynced log entries (batched)
    let logs = db.find_logs_where(hive_synced_at IS NULL LIMIT 1000);

    // 4. Batch sync logs
    if !logs.is_empty() {
        hive.sync_log_batch(logs).await?;
        db.mark_logs_synced(logs.iter().map(|l| l.id)).await?;
    }
}
```

## Merge Operations

### Project Merge

Merging two swarm projects:

1. Select target project (the one to keep)
2. Select source project (the one to merge from)
3. Transfer all node links from source to target
4. Transfer all tasks from source to target
5. Delete source project

```sql
-- Move node links
UPDATE swarm_project_nodes
SET swarm_project_id = $target_id
WHERE swarm_project_id = $source_id;

-- Move tasks
UPDATE swarm_tasks
SET swarm_project_id = $target_id
WHERE swarm_project_id = $source_id;

-- Delete source
DELETE FROM swarm_projects WHERE id = $source_id;
```

### Label Merge

Merging two labels:

1. Update all task_labels references from source to target
2. Update all node local labels linked to source
3. Delete source label

```sql
-- Update task labels
UPDATE task_labels
SET label_id = $target_id
WHERE label_id = $source_id;

-- Notify nodes to update local links
-- (via WebSocket broadcast)

-- Delete source
DELETE FROM labels WHERE id = $source_id;
```

### Template Merge

Similar to label merge, updates all references then deletes source.

## Version Conflict Resolution

The swarm uses optimistic concurrency with last-write-wins for most entities:

### Task Versions

```rust
// On update attempt
if request.version != db.current_version {
    return Err(ConflictError {
        current: db.task.clone(),
        requested_version: request.version,
    });
}

// Accept update, increment version
db.update_task(request.task, version + 1);
```

### Label/Template Versions

Labels and templates use higher-version-wins to handle simultaneous updates from multiple nodes:

```rust
// On sync
if incoming.version > db.current_version {
    db.update(incoming);
} else {
    // Incoming is stale, send current version back
    send_current_version_to_node(node_id, db.current);
}
```

## Offline Handling

### Node Disconnection

When a node disconnects from the hive:

1. WebSocket connection closes
2. Node status updated to `offline` on hive
3. Node continues serving cached data
4. Write operations blocked (require hive)

### Reconnection

When a node reconnects:

1. Authenticate with API key
2. Hive sends current sync state
3. Node reconciles local cache with hive state
4. Node re-registers all linked projects
5. Background sync service resumes

### Queued Operations

During disconnection, these operations are queued:
- Execution logs (stored locally, synced on reconnect)
- Task attempts (created locally, synced on reconnect)

These operations are blocked until reconnection:
- Task create/update/delete
- Label create/update/delete
- Template create/update/delete

## Performance Considerations

### Batching

- Log entries are synced in batches of up to 1000
- Label sync sends all labels in one message
- Task broadcasts are individual for real-time updates

### Caching

- Nodes cache all swarm entities locally
- Cache is refreshed on reconnection
- Individual updates maintain cache consistency

### Connection Management

- WebSocket ping/pong for keepalive
- 60-second timeout for offline detection
- Automatic reconnection with exponential backoff

## Security

### Authentication

- Nodes authenticate with API keys
- API keys are scoped to organizations
- JWT tokens used for direct node connections

### Authorization

- Nodes can only access their organization's data
- Users must have project access to view logs
- Admin role required for destructive operations

### Data Validation

- All incoming data validated against schema
- UUIDs verified to exist and be accessible
- Version numbers prevent replay attacks

## Migration Notes (v0.0.125+)

### Legacy Fields Removed

The following legacy fields have been removed as part of the ElectricSQL migration:

| Table | Field Removed | Reason |
|-------|--------------|--------|
| `tasks` | `is_remote` | Task origin no longer matters; execution location is tracked via attempts |
| - | `shared_tasks` table | ElectricSQL syncs tasks directly to `tasks` table |

### ElectricSQL Task Sync

Tasks are now synced via ElectricSQL instead of WebSocket polling:

1. **Hive → Node**: ElectricSQL shapes push task changes in real-time
2. **Node → Hive**: Task create/update messages sent via WebSocket
3. **Conflict Resolution**: `shared_task_id` column used for upsert on sync

### git_repo_path Constraint Handling

The `projects.git_repo_path` column has a UNIQUE constraint. When syncing remote
projects from nodes, if ANY project already exists with the same path (local OR
remote from another node), the remote project sync is skipped to avoid constraint
violations. This commonly occurs when:

- The same repository is checked out on multiple machines
- Multiple nodes in a swarm share the same repository path (e.g., `/home/david/Code/vibe-kanban`)

The sync logic prioritises the first project synced with a given path. Subsequent
nodes with the same path are detected and logged but their project entries are
not duplicated.

## Task Archive Proxy Pattern

When archiving hive-synced tasks, nodes proxy the archive operation to the hive rather than
modifying local state directly. This ensures archive status syncs consistently across all nodes.

### Archive Flow

```text
┌──────────┐         ┌──────────┐         ┌──────────┐
│  Node A  │         │   Hive   │         │  Node B  │
└────┬─────┘         └────┬─────┘         └────┬─────┘
     │                    │                    │
     │ UpdateSharedTask   │                    │
     │ (archived_at=now)  │                    │
     │───────────────────►│                    │
     │                    │                    │
     │  Updated Task      │                    │
     │  (version++)       │                    │
     │◄───────────────────│                    │
     │                    │                    │
     │                    │ TaskUpdated        │
     │                    │ (archived_at=now)  │
     │                    │───────────────────►│
     │                    │                    │
```

### API Request Format

The archive operation uses the standard `UpdateSharedTaskRequest` with the `archived_at` field:

```rust
// Archive request
UpdateSharedTaskRequest {
    title: None,
    description: None,
    status: None,
    archived_at: Some(Some(Utc::now())),  // Set timestamp
    version: Some(current_version),
}

// Unarchive request
UpdateSharedTaskRequest {
    title: None,
    description: None,
    status: None,
    archived_at: Some(None),  // Clear timestamp
    version: Some(current_version),
}
```

### Subtask Handling

When archiving a hive-synced parent task, the hive propagates the archive status to all
subtasks. Nodes do not need to archive subtasks individually—the hive handles this
server-side to ensure consistency.

### Local State Update

After a successful archive/unarchive operation, the node updates its local task cache
via `Task::upsert_remote_task()` to ensure the local state reflects the hive's response
immediately, without waiting for the next sync cycle.

## Orphaned Task Detection

An **orphaned task** is a task that has a `shared_task_id` but the project is no longer linked to the Hive (or the project was deleted from Hive).

### How Orphaned Tasks Occur

1. **Project Unlinked**: User manually unlinks a project from swarm
   ```rust
   // Project unlinked - remote_project_id cleared
   project.remote_project_id = None;
   ```
   Tasks that still have `shared_task_id` set are now orphaned

2. **Project Deleted from Hive**: The swarm project is removed from Hive
   - Local projects that were linked to this project lose their connection
   - Tasks with `shared_task_id` matching the deleted project become orphaned

3. **Connection Lost**: Hive connection is lost for extended period
   - Tasks can't sync but `shared_task_id` remains set
   - When connection is restored, tasks may be out of sync

### Sync Health API

The `/api/projects/{id}/sync-health` endpoint provides project sync health information:

**Request**: `GET /api/projects/{project_id}/sync-health`

**Response** (`SyncHealthResponse`):
```typescript
{
  "success": true,
  "data": {
    "is_linked": boolean,          // Is project linked to Hive?
    "remote_project_id": string | null,  // Hive project ID
    "orphaned_task_count": number,    // Number of orphaned tasks
    "has_sync_issues": boolean,     // Are there any issues?
    "issues": SyncIssue[]           // Array of specific issues
  }
}
```

**Issue Types**:
- `OrphanedTasks { count: i64 }` - Tasks with shared_task_id but no Hive link
- `ProjectNotLinked` - Project has no remote_project_id but has swarm tasks

## Sync Health Checking

To detect and resolve sync state issues, nodes perform regular health checks on linked projects. This functionality addresses the scenario where projects have stale `remote_project_id` values pointing to non-existent Hive projects, and tasks have orphaned `shared_task_id` values that can cause "shared task not found" errors during archive operations.

### Detection Implementation

The sync health system identifies orphaned tasks by checking for tasks that have a `shared_task_id` but belong to projects that are not properly linked to the Hive. This is accomplished through the `count_orphaned_for_project()` function:

```rust
pub async fn count_orphaned_for_project(
    pool: &SqlitePool,
    project_id: Uuid,
) -> Result<i64, sqlx::Error> {
    let count = sqlx::query_scalar!(
        r#"SELECT COUNT(*) as "count!: i64"
           FROM tasks
           WHERE project_id = $1
             AND shared_task_id IS NOT NULL"#,
        project_id
    )
    .fetch_one(pool)
    .await?;
    Ok(count)
}
```

### Sync Health API

Projects expose a sync health endpoint that provides detailed status information:

- `GET /api/projects/{id}/sync-health` - Returns `SyncHealthResponse` with information about linking status, orphaned task counts, and any sync issues

The response includes:
- `is_linked` - Whether the project is properly linked to a Hive project
- `remote_project_id` - The linked Hive project ID (if any)
- `orphaned_task_count` - Number of tasks with orphaned sync state
- `has_sync_issues` - Boolean indicating if sync issues are detected
- `issues` - List of specific sync issues found

### Unlink Process

When sync issues are detected, users can unlink projects to clear all sync state and start fresh:

- `POST /api/projects/{id}/unlink-swarm` - Clears sync references for a project

The unlink process:
1. Clears the `remote_project_id` on the project
2. Clears `shared_task_id` on all tasks in the project
3. Clears `hive_synced_at` on related task attempts
4. Optionally notifies the Hive about the unlink operation

### Bulk Operations

The system provides bulk fix capabilities through the UI allowing users to resolve sync issues across multiple projects simultaneously:

- Swarm Health Section in settings displays an overview of sync issues
- "Fix All Issues" button performs bulk unlink operations to clean up sync state

## Frontend Components

### SwarmHealthSection

Located at: `frontend/src/components/swarm/SwarmHealthSection.tsx`

Displays overall swarm health and provides bulk fix options:

```typescript
// Aggregates health across all projects
const swarmHealth = useSwarmHealth();
// Returns: {
//   totalProjects: number,
//   projectsWithIssues: number,
//   totalOrphanedTasks: number,
//   isHealthy: boolean,
//   isLoading: boolean
// }
```

**Features**:
- Hidden when no issues detected (`isHealthy === true`)
- Shows count of projects with sync issues
- Shows total orphaned tasks count
- "Fix All Issues" button to bulk unlink all broken projects
- Shows loading state during bulk operation
- Displays success/error feedback

### useSwarmHealth Hook

Located at: `frontend/src/hooks/useSwarmHealth.ts`

Aggregates sync health data across all projects using React Query:

```typescript
// Fetches all projects
const projectsQuery = useQuery({
  queryKey: ['projects'],
  queryFn: () => projectsApi.getAll(),
});

// Fetches sync health for each project in parallel
const syncHealthQueries = useQueries({
  queries: projectsQuery.data?.map((project) => ({
    queryKey: ['project', project.id, 'sync-health'],
    queryFn: () => projectsApi.getSyncHealth(project.id),
    enabled: projectsQuery.isSuccess && !!project.id,
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
  })) || [],
});
```

### SyncHealthIndicator Component

Located at: `frontend/src/components/projects/SyncHealthIndicator.tsx`

Displays sync health status on project cards:

```typescript
// Shows sync status
export function SyncHealthIndicator({ projectId }: Props) {
  const { data } = useProjectSyncHealth(projectId);

  // Orphaned tasks warning
  if (data?.has_sync_issues) {
    return <AlertTriangle className="text-amber-500" />;
  }

  // Healthy state (optional indicator)
  return null;
}
```

## Database Schema

### Sync-Related Tables

**projects** table:
```sql
-- Key sync fields
remote_project_id        UUID    -- ID of project in Hive (NULL = not linked)
remote_last_synced_at   DATETIME -- Last successful sync timestamp
source_node_id         UUID    -- Node that created/owns this project
source_node_name        TEXT     -- Human-readable node name
source_node_status     TEXT     -- 'online' | 'offline' | 'unknown'
source_node_public_url  TEXT     -- URL for direct log streaming
```

**tasks** table:
```sql
-- Sync fields
shared_task_id         UUID    -- Global task identifier across swarm
remote_last_synced_at   DATETIME -- Last time task was synced from Hive
remote_assigned_node_id UUID    -- Node currently executing this task (assigned by Hive)
```

## Error Cases and Recovery

### Project Not Found on Unlink

**Symptom**: When unlinking, error "Project not found"

**Cause**: Project was deleted or doesn't belong to user's organization

**Recovery**: Refresh project list before attempting unlink

### Hive Connection Issues

**Symptoms**:
- Tasks not syncing between nodes
- "task sync failed" errors in logs
- Remote last sync timestamp not updating

**Recovery**:
1. Check `VK_HIVE_URL` environment variable
2. Verify `VK_NODE_API_KEY` is valid
3. Check Hive server status (if accessible)
4. Restart node application to re-establish WebSocket connection

### Orphaned Task Cleanup

**Symptom**: Tasks show as orphaned even after project is re-linked

**Cause**: `shared_task_id` wasn't cleared on re-link

**Recovery**: Manually clear sync state before re-linking:
1. Unlink project completely
2. Re-link to swarm project
3. This clears all stale sync state

## Security Considerations

### API Key Management

- API keys are stored in environment: `VK_NODE_API_KEY`
- Never log or trace API keys
- Keys can be rotated via Hive web interface
- Different nodes can use different API keys for the same organization

### WebSocket Security

- WebSocket connections use TLS/WSS for encrypted transport
- Message payload is limited to 1MB
- Rate limiting applies to prevent abuse
- Each connection is authenticated with API key on handshake

## Testing

### Sync Health Endpoint

Test the sync health endpoint:

```bash
# Get sync health for a project
curl http://localhost:3001/api/projects/{project_id}/sync-health

# Expected response for healthy project
{
  "success": true,
  "data": {
    "is_linked": true,
    "remote_project_id": "uuid-here",
    "orphaned_task_count": 0,
    "has_sync_issues": false,
    "issues": []
  }
}

# Expected response for project with orphaned tasks
{
  "success": true,
  "data": {
    "is_linked": true,
    "remote_project_id": "uuid-here",
    "orphaned_task_count": 5,
    "has_sync_issues": true,
    "issues": [
      { "OrphanedTasks": { "count": 5 } }
    ]
  }
}
```

### Unlink Operation

Test unlinking a project:

```bash
curl -X POST http://localhost:3001/api/projects/{project_id}/unlink-swarm \
  -H "Content-Type: application/json" \
  -d '{ "notify_hive": false }'

# Expected response
{
  "success": true,
  "data": {},
  "message": "Project unlinked from swarm"
}
```

## Related Code Files

| Component/File | Path | Purpose |
|--------------|------|---------|
| Sync Health Handler | `crates/server/src/routes/projects/handlers/core.rs:623` | Provides project sync health info |
| Unlink Handler | `crates/server/src/routes/projects/handlers/core.rs` | Unlinks project from swarm |
| Task Cleanup | `crates/db/src/models/task/cleanup.rs` | Clears sync state from tasks |
| Orphaned Count Query | `crates/db/src/models/task/sync.rs:404` | Counts orphaned tasks |
| SyncHealthResponse Type | `crates/server/src/routes/projects/types.rs:222` | TypeScript types for sync health |
| SwarmHealthSection | `frontend/src/components/swarm/SwarmHealthSection.tsx` | Displays aggregate swarm health |
| useSwarmHealth Hook | `frontend/src/hooks/useSwarmHealth.ts` | Aggregates health data |
| useProjectSyncHealth Hook | `frontend/src/hooks/useProjectSyncHealth.ts` | Single project health |
| NodeProjectsSection | `frontend/src/components/swarm/NodeProjectsSection.tsx:650` | Project linking/unlinking UI |
| SwarmSettings | `frontend/src/pages/settings/SwarmSettings.tsx:105` | Settings page with health section |
| SyncHealthIndicator | `frontend/src/components/projects/SyncHealthIndicator.tsx` | Project card health indicator |

## Related Documentation

- [Task Archiving](/features/task-archiving) - User guide for archiving tasks
- [Swarm/Hive Setup Guide](/swarm-hive-setup) - Configuration instructions
- [Project Linking](/core-features/project-linking) - User guide for linking
- [Swarm Management](/core-features/swarm-management) - UI documentation
- [Auth Token Management](/architecture/auth-token-management) - Token refresh and error handling
